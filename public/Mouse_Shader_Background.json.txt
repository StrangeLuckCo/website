{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"video","usesPingPong":false,"src":"https://strange-luck.s3.us-east-1.amazonaws.com/homepage_hero/WEBSITE-REEL.mp4","trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uVideoTexture;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor;const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);ivec2 texSize = textureSize(uVideoTexture, 0); float texWidth = float(texSize.x); float texHeight = float(texSize.y); float videoAspect = texWidth / texHeight;float screenAspect = (uResolution.x / uResolution.y); vec2 centeredUV = uv;if (0 == 1) { vec2 centered = uv - 0.5; if (screenAspect < videoAspect) { centeredUV = vec2( (uv.x - 0.5) * (screenAspect / videoAspect), uv.y - 0.5) + 0.5; } else { centeredUV = vec2( uv.x - 0.5, (uv.y - 0.5) * (videoAspect / screenAspect) ) + 0.5; } centeredUV += (bg.rg * 2.0 - 1.0) * 0.0000; } else { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); centeredUV = centeredUV - pos; centeredUV.x *= screenAspect; centeredUV = (centeredUV) / 1.1740; centeredUV = centeredUV * rot(0.0027 * 2.0 * PI); centeredUV.x /= videoAspect; centeredUV += 0.5; centeredUV += (bg.rg * 2.0 - 1.0) * 0.0000; if(centeredUV.x < 0.0 || centeredUV.x > 1.0 || centeredUV.y < 0.0 || centeredUV.y > 1.0) { fragColor = bg; return; } }vec4 color = texture(uVideoTexture, centeredUV);if(0 > 0) { color.rgb = blend(0, bg.rgb, color.rgb); }color.rgb = mix(bg.rgb, color.rgb, 1.0000) * color.a; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouse","usesPingPong":true,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 pixelate(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; float scale = 0.5000 / 2.0; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - 0.5, (scale + 0.01) / 12.0); return vec2( uv.x - modulate.x / aspectRatio + (0.08333 * scale) / 2.0, uv.y - modulate.y + (0.08333 * scale) / 2.0 ); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 pixelTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; vec2 pixelated = uv - distorted; color = texture(uTexture, pixelated); color.rgb = chromatic_aberration(color.rgb, pixelated, distorted * 0.2500 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return pixelTrail(uv, mouseDir, strength); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;pingpongUv = pixelate(pingpongUv);vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.5000 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.2960 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;float distLine = distance(uPreviousMousePos, uMousePos);float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.0000, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 0.0000 * 0.03) + 0.0000 * 0.015, 0.0000); vec3 lastFrameColor = texture(uPingPongTexture, sampleUv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); mouseColor = pow(mouseColor, vec3(2.2)); float intensity = min(0.7, dist * 10.0) * s * 0.4; vec3 draw = mix(lastFrameColor, mouseColor, intensity); draw *= pow(0.2700, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"chromab","usesPingPong":false,"amount":0.126,"speed":0.25,"trackMouse":0.28,"mouseMomentum":0,"parentLayer":"34e2f6e7-fee6-4bd6-aed2-4440a4b33755","animating":false,"isMask":0,"states":{"appear":[],"scroll":[],"hover":[{"type":"hover","id":"3bdb63e4-b9db-4c82-b088-a83e16001b00","prop":"amount","transition":{"duration":600,"ease":"easeInOutSine","delay":150},"progress":0,"rawProgress":0,"lastProgress":null,"value":0.25,"triggerOnElement":1,"breakpoints":[],"uniformData":{"type":"1f","name":"uAmount"}}]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform float uTime;uniform vec2 uMousePos;out vec4 fragColor; const float PI = 3.1415926;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.155579399141631, 0.7575107296137339) + mix(vec2(0), (uMousePos-0.5), 0.2800); float angle = ((0.0054 + uTime * 0.05) * 360.0) * PI / 180.0; vec2 rotation = vec2(sin(angle), cos(angle)); vec2 aberrated;aberrated = uAmount * rotation * 0.03 * mix(1.0, distance(uv, pos) * (1.0 + 0.1700), 0.1700); vec4 left = vec4(0); vec4 right = vec4(0); vec4 center = vec4(0);float steps = max(2., min(float(16), 24.)); float invSteps = 1.0 / (steps + 1.0);for (float i = 0.0; i <= steps; i++) { vec2 offset = aberrated * (i * invSteps); left += texture(uTexture, uv - offset) * invSteps; right += texture(uTexture, uv + offset) * invSteps; } for (float i = 0.0; i <= steps; i++) { vec2 offset = aberrated * ((i / steps) - 0.5); center += texture(uTexture, uv + offset) * invSteps; }vec4 color = texture(uTexture, uv); if(0 == 0) { color.r = left.r; color.g = mix(color.g, center.g, float(1)); color.b = right.b; } else if(0 == 1) { color.r = mix(color.r, center.r, float(1)); color.g = left.g; color.b = right.b; } else if(0 == 2) { color.r = right.r; color.g = left.g; color.b = mix(color.b, center.b, float(1)); }color.a = max(max(left.a, center.a), right.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}}],"options":{"name":"Hero","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"1.4.19","id":"aGpjq2r5WqZlkA3BozIn"}